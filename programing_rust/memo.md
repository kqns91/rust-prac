# プログラミング Rust

## 所有権

- メモリ管理
  - C/C++
    - 所有者が被所有者の生存期間を決定し、他の者はその決定を尊重する
  - Rust
    - 全ての値はその生存期間を決定する唯一の所有者を持つ
    - 所有者がドロップされると、その値もドロップされる
    - 全ての値は、なんらかの変数がルートになっているツリーのメンバー
- Box<T>
  - ヒープ上の型 T の値へのポインタを持つ

### 移動

- 移動のタイミング
  - 変数への代入
  - 関数への引数の受け渡し
  - 関数からの戻り値
- 受け渡し先が生存期間の制御を引き継ぐ
- 代入
  - Python
    - 参照カウントを行うことを代償に、代入を安価にした
  - C++
    - ディープコピーを行うことを代償に、メモリの所有者を明確にした
  - Rust
    - 代入元から代入先への値の移動が行われ、代入元は未初期化状態になる
- ループ内で変数から値の移動はできない
- インデックスされた値の移動はできない
  - ポップして取り出す
  - 取り出した最後の要素
  - 代わりの値と入れ替える

### Copy 型

  - 単純なビット単位のコピーだけで事足りる型（数値型、char 型、bool 型、Copy 型の固定長配列など）
  - 独自定義の型は Copy 型ではないが、全てのフィールドが Copy 型であれば Clone トレイトを実装することで Copy トレイトを実装できる。
  - ただし非 Copy 型へ変更するとコードを書き直す必要があるため責任が大きい

### Rc と Arc

- ほとんどの値が唯一の所有者を持つ持つ
- Rc：参照カウンタ
- Arc：スレッドセーフな参照カウンタ
- 最後の参照がドロップされると、値もドロップされる
- 参照カウントループ
  - 2 つの値が互いに参照し合っている場合、参照カウントが 0 にならない
  - メモリリーク
  - Weak トレイトを使って循環参照を解消する

## 参照

- 所有者を持たないポインタ型
- 参照先の生存期間に何の影響も持たない。参照先よりも長生きしてはいけない。
- 種類
  - 共有参照：読むことはできるが、変更することはできない。
  - 可変参照：読み出すことも変更することもできる。同じ値に対する可変参照と、他の参照は同時に使用できない。
- ベクタの共有参照に対する繰り返し実行は要素への共有参照を作るように定義されている。
- 値渡し：所有権を移動する
- 参照渡し：所有権を移動せず、値への参照を渡す

### 値としての参照

- go と同じで、. 演算子が必要に応じて暗黙に左のオペランドを参照解決する
- 比較演算子は、参照の連鎖を見通すことができるので、参照の比較が可能
- 参照が null になることはない。初期化するまで変数を使うことはできない。
- 式にも参照を使うことができる
- ファットポインタ
  - スライス：データへのポインタと長さ
  - 特定のトレイトを実装した値：データのアドレスとその値に対応するトレイトの実装

### 参照の安全性

- ローカル変数を借用して外に持ち出すことはできない
